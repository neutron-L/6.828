1. 不需要，因为进程进入内核的时候，会把进程的I/O特权级保存在trapframe中，恢复执行的时候会使用之前在用户态执行时的I/O特权级。
inc/lib.h 中的sys_exofork为什么需要定义为inline？
我尝试按照和其他系统调用函数一致的方式定义sys_exofork，但是不检查返回值，即check参数为0（因为父进程中的返回值
是子进程的id，此时返回值是大于0的），也可以通过grade；

fs/bc.c中的bc_pgfault函数，读入一个缺页的块后再检查该页是否是未分配的页，因为访问一个未分配的页是非法的。但是为什么不在
一开始就判断呢？因为bitmap所在的块在初始化的时候并未被读入。bitmap也是文件映射I/O区域的某个地址，如果bitmap未被读入而
触发缺页故障，在缺页故障处理函数中首先根据bitmap判断是否该地址所在的磁盘块是否已经分配，则需要再次访问bigmap，而bitmap
本身又不在内存，因此会不断出发缺页故障。

Challenge：扩展JOS，支持exec。
    添加了exec的系统调用，因为文件系统是在用户态实现，如果直接把exec中的程序名传入内核，由内核读取文件
    内容再写入进程的内存空间，会比较麻烦。
    所以exec函数在进入内核之前，将文件的内容读取在UTEMP开始的4MB空间中。文件系统支持的最大的文件大小为（10 + 1024） * 4096
    略大于4MB，其实可以选择将文件内容读入到UTEMP再往下一些，但是为了方便，我们假设文件大小不大于4MB。
    模仿env.c中的load_icode和spawn.c中的map_segment以及init_stack函数，重置用户栈和内存空间（代码段、数据段）
    需要注意从0xD0000000(FDTABLE)以上的内容就不需要再unmap了，否则打开文件的数据会被删除掉，write系统调用会无法工作，
    只能通过cprintf输出。