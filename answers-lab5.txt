1. 不需要，因为进程进入内核的时候，会把进程的I/O特权级保存在trapframe中，恢复执行的时候会使用之前在用户态执行时的I/O特权级。
inc/lib.h 中的sys_exofork为什么需要定义为inline？
我尝试按照和其他系统调用函数一致的方式定义sys_exofork，但是不检查返回值，即check参数为0（因为父进程中的返回值
是子进程的id，此时返回值是大于0的），也可以通过grade；

Challenge：扩展JOS，支持exec。
    添加了exec的系统调用，因为文件系统是在用户态实现，如果直接把exec中的程序名传入内核，由内核读取文件
    内容再写入进程的内存空间，会比较麻烦。
    所以exec函数在进入内核之前，将文件的内容读取在UTEMP开始的4MB空间中。文件系统支持的最大的文件大小为（10 + 1024） * 4096
    略大于4MB，其实可以选择将文件内容读入到UTEMP再往下一些，但是为了方便，我们假设文件大小不大于4MB。
    模仿env.c中的load_icode和spawn.c中的map_segment以及init_stack函数，重置用户栈和内存空间（代码段、数据段）
    需要注意从0xD0000000(FDTABLE)以上的内容就不需要再unmap了，否则打开文件的数据会被删除掉，write系统调用会无法工作，
    只能通过cprintf输出。