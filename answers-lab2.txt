1. uintptr_t. x的值是将指针value的值类型转换得来的，而value保存的是虚拟地址，
因为在内核代码中，对value解引用需要经过mmu转换。
2. 当前内核主要映射了4段虚拟内存，分别是：
    a. 将VPAGES起始处的虚拟内存映射到pages数组所在的物理地址；
    b. 将UVPT起始处的虚拟内存映射到kern_pgdir所在的物理地址；
    c. 将KERNBASE - KSTKSIZE起始处的虚拟内存映射到内核栈所在的物理地址
    d. 将KERNBASE起始处的虚拟内存映射到全部的物理内存

    VPAGES在页目录项中的索引为0xef000000>>22 = 0x3bc，映射区域大小为4MB，页目录项中占一项
    UVPT在页目录项中的索引为0xef400000>>22 = 0x3bd，映射区域大小为4MB，页目录项中占一项
    KERNBASE - KSTKSIZE在页目录项中的索引为0xefff8000>>22 = 0x3bf，映射区域大小为32KB，页目录项中占一项
    KERNBASE在页目录项中的索引为0xf0000000>>22 = 0x3c0，映射区域大小为256MB，页目录项中占64项，从960~1023
3. 页表项中没有设置PTE_U，则用户不可访问（读或写），即只能处于内核态（此时已经在执行内核代码）访问。
4. 内核将物理内存映射到KERNBASE开始的虚拟地址，则能映射的最大物理内存为1<<32-KERNBASE，即256MB。
5. 假设拥有256MB物理内存，为了管理这些内存的开销，不得不牺牲一部分物理页面来存放页表以支持虚拟内存，这部分内存包括
    用来存放页目录表（1个）和页表（若干个），我们计算此时需要的页表的数量。
    a. 映射VPAGES起始处的4MB虚拟内存，pages数组的实际大小为页数*PageInfo大小，页数为256MB/4KB=64K个，PageInfo
        大小为（考虑对齐）8字节，因此pages数组大小为2^19字节，需要占据128页，中间页表需要一个即可，此处需要128+1=129个
        物理页；
    b. 映射内核栈，内核栈大小为8页，因此需要一个1中间页表；
    c. 映射所有物理内存，从页目录表项960~1023，一共需要64个中间页表；
    其实，通过判断那些页目录项有效，即可判断中间页表的数目（一个页表项指向一个中间页目录），因此需要128页存放管理物理
    内存，而需要66页存放中间页表，1页存放页目录。
    通过在pmap.c中，定义一个静态变量，每次page_alloc调用成功返回一个物理页则递增，而每次page_free则递减，
    并在三次boot_map_region调用前后打印uses的值，显示调用前为0，调用后为66，符合上述推导过程。
    当前系统可用内存显示为131072K可用，即128MB，为支持的最大物理内存的一半，打印出pages数组的大小，为0x40000字节，即
    需要128页存放，因此，最大物理内存的情况下需要256页存放pages数组。
6. entry.S设置了新的页表后，执行了一条jmp指令，通过该指令设置了pc的值高于KERNBASE（因为jmp的目的地址是
在entry.S中，链接地址高于KERNBASE）。之所以还能在低于KERNBASE的地址的指令执行，是因为页表中包含从虚拟内存
到物理内存起始处的4MB（此范围涵盖了内核占据的实际物理内存区域）的一对一映射，此时照样可以执行物理内存中的正确位置
的内核指令。因为开启分页后，内核代码将不直接在物理内存空间执行，转而在虚拟空间执行。当内核完成对虚拟地址空间中的
基本映射（栈、代码段等）后，将不再保存这一段一对一的4MB大小的映射关系（pmap.c中的mem_init完成虚拟空间的映射工作）。