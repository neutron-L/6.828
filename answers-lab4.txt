1. 因为mentry.S被链接到内核代码中，随着内核一起加载到内存，其加载地址和链接地址
并不是MPENTRY_PADDR，内核只是通过将代码复制到物理内存MPENTRY_PADDR，因此mentry.S
中的指令在实模式下执行时，如果要获取其物理地址，只能通过该宏定义计算。

2. 即使使用大内核锁，但是每个进程陷入内核态时，其用户态的状态均压栈保存在内核栈中，每个cpu使用一个独立的内核栈，
当每个cpu均进入内核态时，将当前cpu上运行的进程的状态压入cpu的内核栈，然后再竞争内核锁。如果只有一个内核栈，不同进程
进入内核态时会覆盖之前进入内核态的进程的状态信息。究其原因，是因为内核锁只能控制内核中的关键代码只能有一个cpu在执行，
而不能控制每次只能有一个cpu上的进程可以陷入内核态。

3. 因为每个用户态进程也包含内核空间的映射，因此用户进程的页表也可以使用在内核空间的虚拟地址，只要在内核态，就可以访问该地址。

4. 进程之间的切换对进程是不可见的，即对于用户来说，只能感知到进程的执行速度变慢了，因此内核必须确保
切换进程时，保存进程在用户态的执行状态，以便后续调度该进程时可以恢复到之前的环境。当进程进入内核时，压栈保存了
进程用户态执行时的寄存器内容，trap函数负责将内核栈中的内容复制到当前进程的trapframe中。下一次调度到该进程时，
通过调整栈指针为trapframe的地址，弹栈恢复进程的状态。


Challenge：sfork。与fork类似，但是只将栈所占的一页映射为COW，而父进程中的其他用户空间的页，同样映射到
子进程的虚拟地址空间中。实现父进程和子进程共享，forkshare.c是一个测试程序。